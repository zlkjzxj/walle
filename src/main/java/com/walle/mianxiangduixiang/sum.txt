
一，面向对象
类是模子，确定对象拥有的特征（属性）和行为（方法）
类的组成：属性和方法。

2.成员变量，局部变量
 作用于不同
 局部变量必须初始化，不然会报错。
 成员变量默认给初始值；
 局部变量可以重名
 两类变量重名，局部优先。
3.构造方法
 new 的知识构造方法。系统自动生成无参的构造方法
 自定义有参构造方法，系统就不会生成午餐的构造方法
 构造方法不单可以赋值，而且还可以判断赋的值是否正确。
3.static
  static 声明的变量在类加载（编译）的时候就由系统分配出类存一直存放，程序运行就一直存在,程序结束后才会释放。
  而非static的对象每次使用都要new一下。 static 就不用，直接类名点就能调用 ，eg Integer.parseInt() ,Float.parseFloat()
  这样的变量和方法我们又叫做类变量和方法。
  静态方法中可以调用类的静态成员变量， 但是不能调用非静态成员变量。如果非要使用那就new一下这个类。
  普通方法中可以调用静态变量
  静态方法中不能直接调用非静态方法，必须用类new，例如 main 方法
4.静态块
  静态初始化块只在类加载时执行，且只会执行一次，同时静态初始化块只能给静态变量赋值，不能初始化普通的成员变量。
  static{}

二.三大特性 封装、继承、多态
   1.封装
    将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过提供的方法来操作和访问。
    好处：只能通过方法来访问，隐藏类的细节，方便修改和实现。  例如，输入年龄不符合规范，可以在set方法做限制。

    2.继承
    1.java是单继承
    2.子类拥有父类的所有属性和方法（private修饰的无效）
    3.方法的重写：子类对父类方法不满意，可以重写父类的方法。调用时有限调用子类
    满足条件：返回值类型、方法名、参数类型及个数 都相同
    4.初始化顺序 父类的属性--父类的构造方法--子类的属性--子类的构造方法

    final 关键字
    1.如果类上有final，则该类不允许被继承
    2.方法上有final，子类不能重写
    3.final修饰的属性 如果赋值了，不可以在其他地方修改，如果不初始化，必须在构造方法初始。final 修饰的局部变量不能修改。

    3.多态
    1.两个类必须是继承关系
    2.父类的对象指向子类或者本类
    3.父类的指向不能调用子类独有的方法
    4.如果子类没有重写父类的方法，父类直线子类，调用的是子类继承父类的方法

    类型转换
    向上，自动类型转换 小转大
    向下，可能溢出 强制类型转换 使用instanceof 关键字判断是否能强制类型转换
    Father father = new Son();
    Son son = (Son) father;
    if(father instanceof Daughter){
        Daughter daughter = (Daughter) father;
    }else{
        System.out.println("son cannot be cast to daughter");
    }


三.包
  1.访问修饰符
  private 本类
  默认     本类、同包
  protect 本类、同包、子类
  public  本类、同包、子类、其他
四.内部类
   成员内部类
  1.内部类可以使用任意修饰符
  2.内部类可以访问外部类的所有属性而不受访问控制符的影响。比如访问私有属性
  3.定义了成员内部类之后，必须使用外部对象来创建内部类对象，
  4.外部类不能直接使用内部类的属性和方法
  5.如果外部类和内部类有相同的属性，内部类默认使用自己的，访问外部可以使用  外部类.this.xxx
    静态内部类
  静态内部类不能直接访问外部类的非静态成员，但可以通过 new 外部类().成员 的方式访问
  如果外部类的静态成员与内部类的成员名称相同，可通过“类名.静态成员”访问外部类的静态成员；如果外部类的静态成员与内部类的成员名称不相同，则可通过“成员名”直接调用外部类的静态成员
  创建静态内部类的对象时，不需要外部类的对象，可以直接创建 内部类 对象名= new 内部类();
    方法内部类
   方法内部类就是内部类定义在外部类的方法中，方法内部类只在该方法的内部可见，即只在该方法内可以使用。
   由于方法内部类不能在外部类的方法以外的地方使用，因此方法内部类不能使用访问控制符和 static 修饰符。



五。接口 (就是用来弥补一个类只能继承一个类的缺陷)
 1.接口可以多继承，类是单继承,实现类必须实现包括继承接口在类的所有方法
 2.接口中的常量为 public static final
 3.接口中的方法都是抽象方法，就算不添加public abstract ，系统也会自动加上
 4.一个类，可以实现多个接口
 5.接口可以new 自己，通过匿名内部类实现。 也可以调用new 实现类点方法

六.抽象类
    如果一个类没有足够的信息来描述一个具体的对象，而需要其他具体的类来支撑它，
    那么这样的类我们称它为抽象类。比如new Animal()，我们都知道这个是产生一个动物Animal对象，
    但是这个Animal具体长成什么样子我们并不知道，它没有一个具体动物的概念，所以他就是一个抽象类，
    需要一个具体的动物，如狗、猫来对它进行特定的描述，我们才知道它长成啥样。

    抽象类提供了继承的概念，它的出发点就是为了继承，否则它没有存在的任何意义。
    所以说定义的抽象类一定是用来继承的，同时在一个以抽象类为节点的继承关系等级链中，叶子节点一定是具体的实现类。

     1、抽象类不能被实例化，实例化的工作应该交由它的子类来完成，它只需要有一个引用即可。
     2、抽象方法必须由子类来进行重写。
     3、只要包含一个抽象方法的抽象类，该方法必须要定义成抽象类，不管是否还包含有其他方法。
     4、抽象类中可以包含具体的方法，当然也可以不包含抽象方法。
     5、子类中的抽象方法不能与父类的抽象方法同名。
     6、abstract不能与final并列修饰同一个类。
     7、abstract 不能与private、static、final或native并列修饰同一个方法。、


抽象类和接口的区别
    1.语法层次
    抽象类中可以有 不限修饰符的成员变量，也可以有自己的非抽象方法，
    接口必须是 static final的成员变量,同时所有方法都是抽象的。
    对子类而言，它只能继承一个抽象类（这是java为了数据安全而考虑的），但是却可以实现多个接口
    2.设计层次
    1.抽象层次不同。抽象类是对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。
    2.抽象类所体现的是一种继承关系，要想使得继承关系合理，父类和派生类之间必须存在"is-a" 关系，即父类和派生类在概念本质上应该是相同的。
    对于接口则不然，并不要求接口的实现者和接口定义在概念本质上是一致的， 仅仅是实现了接口定义的契约而已。
    例如鸟和飞机都能飞，所以只能用接口fly,不能把他们归为统一类。

    3.抽象类是自底向上抽象而来的，接口是自顶向下设计出来的。

    例如，我们需要知道毛、狗，他们的共性之后才能定义一个动物抽象类。而接口定义飞，并不需要知道是谁要飞，不管是飞机还是鸟。

异常
Exception runtimeException 大的异常放最后面

字符串
当频繁操作字符串时，就会额外产生很多临时变量。，所以需要用Stringbuilder
StringBuffer和StringBuilder他们的原理和操作基本相同，
区别在于StringBufferd支持并发操作，线性安全的，适 合多线程中使用。StringBuilder不支持并发操作，
线性不安全的，不适合多线程中使用。
新引入的StringBuilder类不是线程安全的，但其在单线程中的性能比StringBuffer高


//基本类型转换为字符串
        int c= 10;
        String s1 = String.valueOf(c);
        String s2 = Integer.toString(c);
        String s3 = c+"";

        System.out.println(s1+s2+s3);

        //字符串转换为基本类型
        String s = "10";
        int d = Integer.parseInt(s);
        int e = Integer.valueOf(s);
        System.out.println(d+e);

        SimpleDateFormat format 时间转化为字符串 ，parse 字符串转化为时间

        Calendar calendar = Calendar.getInstance();
                int year = calendar.get(Calendar.YEAR);
                Date  date = calendar.getTime();


        Math.random()产生（0,1）之间的随机数

集合

因为数组的长度是有限的，不能动态扩展，且获取某个元素必须遍历，所以产生了集合

1.集合和数组的对比
数组的长度固定，集合长度可变
数组只能通过下标访问，类型固定，而有的集合可以通过任意类型查找所映射的具体对象
Collection   list 、queue 、set

Collection {list,queue,set}(序列，队列，集)(ArrayList,linkedList,set) Map{HashMap}

1.list
list 是有序的并且可以重复的，被称为序列
list可以精确增加和删除元素

        //add
        Course course1 = new Course("1","数据接口");
        courses.add(course1);

        //add加序列
        Course course2 = new Course("2","大学数序");
        courses.add(0,course2);

        Course[] course3 = {new Course("3","毛概"),new Course("4","打学语文")};
        //添加多个
        courses.addAll(Arrays.asList(course3));

        //指定位置添加多个
        Course[] course4 = {new Course("3","吗等"),new Course("4","打学按时大大")};

        courses.addAll(2,Arrays.asList(course4));


2.set

hashset 无序并且不可重复 ,所以不能用get()索引的方法，只能用foreach 或iterator,无论添加多少次最终只是一个，每次添加顺序不一样。

3.Map
键值对是无序的，键不能重复。

